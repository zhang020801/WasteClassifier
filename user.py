# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'user.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

## 导入界面设计的库
from PyQt5 import QtCore, QtGui, QtWidgets
from PySide2.QtWidgets import  QPushButton, QWidget, QLabel, QLineEdit,QWidget,QMenuBar,QStatusBar,QFileDialog,QDialog
from PySide2.QtCore import QMetaObject
from PySide2 import QtGui
import cv2
## 导入分类模型使用的库
import numpy as np
import tensorflow as tf
import time
## 导入正则表达式，用于进行字符串的匹配
import re
## 导入请求库，用于请求垃圾分类API接口，用于文字搜索查询分类结果
import requests
## 导入语音识别用到的库
from urllib.request import urlopen
from urllib.request import Request
from urllib.error import URLError
from urllib.parse import urlencode
from urllib.parse import quote_plus
import json,requests
## 导入播放音频文件用到的库
import winsound  
import os  ## 用于删除生成的音频文件

class Ui_MainWindow(object):

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget =QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label_title = QLabel(self.centralwidget)
        self.label_title.setGeometry(350, 20, 100, 100)
        self.label_title.setWordWrap(False)
        self.label_title.setObjectName("label_title")
        self.label_title.setStyleSheet('font:25px')
        self.pushButton_3 = QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(600, 140, 151, 51)
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_4 = QPushButton(self.centralwidget)
        self.pushButton_4.setGeometry(30, 240, 151, 51)
        self.pushButton_4.setObjectName("pushButton_4")
        self.label = QLabel(self.centralwidget)
        self.label.setGeometry(30, 320, 100, 100)
        self.label.setObjectName("label")
        self.label.setStyleSheet("font:20px")
        self.label_2 = QLabel(self.centralwidget)
        self.label_2.setGeometry(50, 380, 100, 100)
        self.label_2.setObjectName("label_2")
        self.label_2.setStyleSheet("font:20px")
        self.label_3 = QLabel(self.centralwidget)
        self.label_3.setGeometry(30, 440, 80, 80)
        self.label_3.setObjectName("label_3")
        self.label_3.setStyleSheet("font:20px")
        self.label_4 = QLabel(self.centralwidget)
        self.label_4.setGeometry(60, 494, 160, 60)
        self.label_4.setObjectName("label_4")
        self.label_4.setStyleSheet("font:20px")
        self.label_5 = QLabel(self.centralwidget)
        self.label_5.setGeometry(230, 220, 521, 271)
        self.label_5.setObjectName("label_5")
        self.label_5.setStyleSheet("font:20px")
        self.label_5.setWordWrap(True)
        self.lineEdit = QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(510, 80, 151, 31)
        self.lineEdit.setObjectName("lineEdit")
        self.pushButton_5 = QPushButton(self.centralwidget)
        self.pushButton_5.setGeometry(660, 80, 93, 31)
        self.pushButton_5.setObjectName("pushButton_5")
        self.pushButton_2 = QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(320, 140, 151, 51)
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton = QPushButton(self.centralwidget)
        self.pushButton.setGeometry(30, 140, 151, 51)
        self.pushButton.setObjectName("pushButton")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar =QMenuBar(MainWindow)
        self.menubar.setGeometry(0, 0, 800, 26)
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "基于TensorFlow的垃圾分类系统"))
        self.label_title.setText(_translate("MainWindow", "用户系统"))
        self.pushButton_3.setText(_translate("MainWindow", "选择识别模型"))
        self.pushButton_4.setText(_translate("MainWindow", "运行识别"))
        self.label.setText(_translate("MainWindow", "识别结果："))
        self.label_2.setText(_translate("MainWindow", "请放置垃圾"))
        self.label_3.setText(_translate("MainWindow", "确认度："))
        self.label_4.setText(_translate("MainWindow", "无"))
        self.label_5.setText(_translate("MainWindow", "                       图像显示区"))
        self.pushButton_5.setText(_translate("MainWindow", "搜索"))
        self.pushButton_2.setText(_translate("MainWindow", "关闭摄像头"))
        self.pushButton.setText(_translate("MainWindow", "打开摄像头"))
    def slot_init(self):
        self.pushButton.clicked.connect(self.button_open_camera_click)
        self.timer_camera.timeout.connect(self.show_camera)
        self.pushButton_2.clicked.connect(self.close_camera)
        self.pushButton_3.clicked.connect(self.select_model)
        self.pushButton_4.clicked.connect(self.predict)
        self.pushButton_5.clicked.connect(self.search)
        self.lineEdit.textChanged.connect(self.handleTextChange)
        self.lineEdit.returnPressed.connect(self.search)

    ## 打开摄像头
    def button_open_camera_click(self):
        self.cap = cv2.VideoCapture(1)  # 打开摄像头准备获取图像
        self.CAM_NUM = 1  # 此参数是关于打开摄像头的问题，0：打开电脑内置摄像头，1/2/3：打开外接USB摄像头
        if self.timer_camera.isActive() == False:
            flag = self.cap.open(self.CAM_NUM)
            if flag == False:
                msg = QtWidgets.QMessageBox.warning(
                    self, u"Warning", u"请检测相机与电脑是否连接正确",
                    buttons=QtWidgets.QMessageBox.Ok,
                    defaultButton=QtWidgets.QMessageBox.Ok)
            else:
                self.timer_camera.start(30)
        pass
    ## 图像显示区域呈现图像
    def show_camera(self):
        flag, self.image = self.cap.read()

        # self.image=cv2.flip(self.image, 1) # 左右翻转
        show = cv2.cvtColor(self.image, cv2.COLOR_BGR2RGB)  # 图像颜色空间转换

        showImage = QtGui.QImage(show.data, show.shape[1], show.shape[0], QtGui.QImage.Format_RGB888)
        self.label_5.setPixmap(QtGui.QPixmap.fromImage(showImage))
        self.label_5.setScaledContents(True)
        pass
    ## 关闭摄像头
    def close_camera(self):
        if self.timer_camera.isActive() != False:
            ok = QtWidgets.QPushButton()
            cacel = QtWidgets.QPushButton()

            msg = QtWidgets.QMessageBox(QtWidgets.QMessageBox.Warning, u"关闭", u"是否关闭！")

            msg.addButton(ok,QtWidgets.QMessageBox.ActionRole)
            msg.addButton(cacel, QtWidgets.QMessageBox.RejectRole)
            ok.setText(u'确定')
            cacel.setText(u'取消')

            if msg.exec_() != QtWidgets.QMessageBox.RejectRole:

                if self.cap.isOpened():
                    self.cap.release()
                if self.timer_camera.isActive():
                    self.timer_camera.stop()
                self.label_5.setText("<html><head/><body><p align=\"center\"><img src=\":/newPrefix/pic/Hint.png\"/><span style=\" font-size:28pt;\">点击打开摄像头</span><br/></p></body></html>")
        pass
    ## 选择模型
    def select_model(self):
        fileNames = []

        fileDialog = QFileDialog(self)
        fileDialog.setViewMode(QFileDialog.Detail)
        fileDialog.setFileMode(QFileDialog.ExistingFiles)
        fileDialog.setNameFilter("all file(*)")
        ret = fileDialog.exec_()
        if ret == QDialog.Accepted:
            fileNames = fileDialog.selectedFiles()
        self.model_path = str(fileNames[0])
        self.model_path = re.match(r'.*/tmp/(.*?)/saved_model.pb', self.model_path, re.M|re.I)
        self.model_path = self.model_path.group(1)
    ## 使用模型预测
    def predict(self):
        # 用于更改UI界面显示
        _translate = QtCore.QCoreApplication.translate

        # 载入预测模型mobilev2
        t = time.time()
        print("Using loaded model to predict...")
        # load_model = load_model("./waste3_model.h5")


        model_path = "./tmp/" + self.model_path
        print(model_path)
        export_path = model_path.format(int(t))
        # export_path = "./tmp/".format(int(t))
        reloaded = tf.keras.models.load_model(export_path)
        #
        np.set_printoptions(precision=4)

        # 摄像头调节分辨率
        # self.cap = cv2.VideoCapture()  # 0是外设，1是内置
        self.cap.set(3, 480)
        self.cap.set(4, 640)
        flag = self.cap.open(self.CAM_NUM)
        # cap.set(cv2.CAP_PROP_EXPOSURE, 500)
        if not self.cap.isOpened():
            print("Cannot open camera")
            exit()

        # cap.set(cv2.CAP_PROP_CONTRAST, 100)  # 曝光 #50
        '''使用cv2.VideoCapture.set设置摄像头分辨率是出现错误'''
        d = 0

        # cv2.namedWindow('waste')

        def gamma_trans(img, gamma):
            # 映射表必须为0-255（改成其他会报错）
            gamma_table = [np.power(x/255.0, gamma) * 255.0 for x in range(256)]  # 建立映射表
            gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)  # 颜色值为整数
            return cv2.LUT(img, gamma_table)  # 图片颜色查表。另外可以根据光强（颜色）均匀化原则设计自适应算法。

        fifo = [0] * 50
        frame_number = 1
        sum = 0
        sum1 = 0
        sum2 = 0
        sum3 = 0

        # 打开摄像头，对输入摄像头的垃圾进行种类预测并分类
        while True:
            # Capture frame-by-frame
            # 读取一张图片
            ret, frame = self.cap.read()

            # ret = self.cap.read()
            # frame = self.cap.read()
            res = frame
            # 插值nearest

            # 对图像进行缩放
            res = cv2.resize(frame, dsize=(224, 224), interpolation=cv2.INTER_NEAREST)
            s = cv2.getTrackbarPos('Gamma_', 'waste')
            value_of_gamma = s * 0.01  # 压缩gamma范围，以进行精细调整
            img_gamma = gamma_trans(res, value_of_gamma)
            # 对输入的视频帧进行处理
            x = res
            x = np.expand_dims(x, axis=0)
            x = x * (1. / 255)
            preditc1 = 0
            # preds = load_model.predict(x)
            # 对使用模型预测视频帧
            preds = reloaded.predict(x)

            print(preds)
            print(preds[0][0])
            predict1 = np.argmax(preds)

            # cv2.imshow('waste', frame)
            show = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            showImage = QtGui.QImage(show.data, show.shape[1], show.shape[0], QtGui.QImage.Format_RGB888)
            self.label_5.setPixmap(QtGui.QPixmap.fromImage(showImage))
            self.label_5.setScaledContents(True)


            # 对垃圾种类进行分类，并更改识别结果的UI显示
            if predict1 == 1:
                print('其他垃圾', predict1)
                self.label_2.setText(_translate("MainWindow", "其他垃圾"))
                ## 确认度
                affirm = preds[0][predict1] * 100
                affirm = round(affirm, 2)
                str1 = str(affirm) + '%'
                self.label_4.setText(_translate("MainWindow", str1))
            elif predict1 == 2:
                print('餐厨垃圾', predict1)
                self.label_2.setText(_translate("MainWindow", "餐厨垃圾"))
                ## 确认度
                affirm = preds[0][predict1] * 100
                affirm = round(affirm, 2)
                str1 = str(affirm) + '%'
                self.label_4.setText(_translate("MainWindow", str1))
            elif predict1 == 3:
                print('有害垃圾', predict1)
                self.label_2.setText(_translate("MainWindow", "有害垃圾"))
                ## 确认度
                affirm = preds[0][predict1] * 100
                affirm = round(affirm, 2)
                str1 = str(affirm) + '%'
                self.label_4.setText(_translate("MainWindow", str1))
            elif predict1 == 4:
                print('可回收垃圾', predict1)
                self.label_2.setText(_translate("MainWindow", "可回收垃圾"))
                ## 确认度
                affirm = preds[0][predict1] * 100
                affirm = round(affirm, 2)
                str1 = str(affirm) + '%'
                self.label_4.setText(_translate("MainWindow", str1))
            elif predict1 == 0:
                print('请放置垃圾', predict1)
                self.label_2.setText(_translate("MainWindow", "请放置垃圾"))
                ## 确认度
                self.label_4.setText(_translate("MainWindow", '无'))
            # buffer prediction result in FIFO
            fifo.pop(0)  # 1st step: remove the frist element
            fifo.append(predict1)  # 2nd step: add new prediction here

            for i in range(50):
                if (fifo[i] == 1):
                    sum = sum + 1
                elif (fifo[i] == 2):
                    sum1 = sum1 + 1
                elif (fifo[i] == 3):
                    sum2 = sum2 + 1
                elif (fifo[i] == 4):
                    sum3 = sum3 + 1
                    # 当要关闭摄像头窗口时，按q即可推出
                    if not ret:
                        print("Can't receive frame (stream end?). Exiting ...")
                        break
                    if cv2.waitKey(25) == ord('q'):
                        break
                    if self.fff == 1:
                        break
                self.fff = 0
        pass
    ## 文字搜索分类结果
    def search(self):
        # 用于更改UI界面显示
        _translate = QtCore.QCoreApplication.translate

        print("进行搜索")
        url = "https://sffc.sh-service.com/wx_miniprogram/sites/feiguan/trashTypes_2/Handler/Handler.ashx?a=GET_KEYWORDS&kw=" + self.text
        headers = {
            "User-Agent": "Mozilla / 5.0(Windows NT 10.0;Win64;x64) AppleWebKit / 537.36(KHTML, likeGecko) Chrome / 80.0.3987.163Safari / 537.36"
        }
        response = requests.get(url = url, headers = headers)
        datalist = response.json().get('kw_arr')

        if (datalist):
            self.search_content = ''
            for item in datalist:
                self.search_content = self.search_content + item.get('Name') + '属于' + item.get('TypeKey') + '；  '
            self.label_5.setText(_translate("MainWindow", self.search_content))   ## 图像显示区域呈现搜索结果
            ## 语音处理
            Speech_synthesis().main(self.search_content)
            winsound.PlaySound(r".\voice.wav",winsound.SND_FILENAME)
            os.remove("voice.wav")
            
        else:
            self.label_5.setText(_translate("MainWindow", "未搜索到该垃圾的相关信息，请尝试图像识别或其他方式。"))
            ## 语音处理
            Speech_synthesis().main("未搜索到该垃圾的相关信息，请尝试图像识别或其他方式。")
            winsound.PlaySound(r".\test.wav",winsound.SND_FILENAME)
            os.remove("voice.wav")
            
        pass
    ## 获得编辑框的内容
    def handleTextChange(self):
        print("输入框被编辑")
        self.text = self.lineEdit.text()
## 语音合成类
class Speech_synthesis():
    ## 百度语音合成
    def __init__(self):
        # 发音人选择, 0为普通女声，1为普通男生，3为情感合成-度逍遥，4为情感合成-度丫丫，默认为普通女声
        self.PER = 0
        # 语速，取值0-15，默认为5中语速
        self.SPD = 5
        # 音调，取值0-15，默认为5中语调
        self.PIT = 5
        # 音量，取值0-9，默认为5中音量
        self.VOL = 5
        # 下载的文件格式, 3：mp3(default) 4： pcm-16k 5： pcm-8k 6. wav
        self.AUE = 6

        self.TTS_URL = "http://tsn.baidu.com/text2audio"

    def key(self):
        #获取token秘钥
        body = {
            "grant_type"    : "client_credentials",
            "client_id"     : "ODrol1dTaLz2YWG4V8IZHuZt",
            "client_secret" : "zPn7VkUxHFtB8vpoTVqz88NmjA9IEKSq"
        }
        url  = "https://aip.baidubce.com/oauth/2.0/token?"
        r = requests.post(url,data=body,verify=True,timeout=2)
        respond = json.loads(r.text)
        return  respond["access_token"]

    ## 语音合成主函数
    def main(self,enobj):
        try:
            tex = quote_plus(enobj)  # 此处re_text需要两次urlencode           
            params = {'tok': self.key(), 'tex': tex, 'per': self.PER, 'spd': self.SPD,
                    'pit': self.PIT, 'vol': self.VOL, 'aue': self.AUE, 'cuid': "123456PYTHON",'lan': 'zh', 'ctp': 1}  # lan ctp 固定参数                
            data = urlencode(params)
            req = Request(self.TTS_URL, data.encode('utf-8'))
            try:
                f = urlopen(req,timeout=4)
                result_str = f.read()
                with open('voice.wav', 'wb') as of:
                    of.write(result_str)
            except Exception as bug:
                return {'state': False,'data':'','msg':'可能是网络超时。'}
        except:
            return {'state': False,'data':'','msg':'可能是网络超时。'}

